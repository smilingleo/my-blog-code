webpackJsonp([0x81b8806e4260],{469:function(e,t){e.exports={data:{allMarkdownRemark:{totalCount:37,edges:[{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2023/HTMX.md absPath of file >>> MarkdownRemark",frontmatter:{title:"新服务器端渲染Web技术：HTMX",date:"September 19, 2023",path:"/2023/server-side-rendering-htmx",tags:["htmx","web"],excerpt:""}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2023/Helix Notes.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Helix概念模型",date:"September 19, 2023",path:"/2023/helix-concept-model",tags:["helix","apache","distributed"],excerpt:""}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2023/团队拓扑.md absPath of file >>> MarkdownRemark",frontmatter:{title:"团队拓扑",date:"August 25, 2023",path:"/2023/team-topologies",tags:["team","platform","management"],excerpt:""}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2023/Cargo Cult AI： 船货崇拜AI.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Cargo Cult AI： 船货崇拜AI",date:"May 16, 2023",path:"/2023/cargo-cult-ai",tags:["LLM","AGI","ChatGPT"],excerpt:""}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2022/2022-11-29 Stable Diffusion Notes.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Stable Diffusion Prompt技巧",date:"November 29, 2022",path:"/2022/stable-diffusion-prompt-tips",tags:["AI","stable diffusion","机器学习"],excerpt:""}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2022/HTMX.md absPath of file >>> MarkdownRemark",frontmatter:{title:"新服务器端渲染Web技术：HTMX",date:"October 20, 2022",path:"/2022/server-side-rendering-htmx",tags:["htmx","web"],excerpt:""}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2022/Helix Notes.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Helix概念模型",date:"September 29, 2022",path:"/2022/helix-concept-model",tags:["helix","apache","distributed"],excerpt:""}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2022/Rsync Replicated File System with Helix.md absPath of file >>> MarkdownRemark",frontmatter:{title:"基于rsync的分布式文件系统Helix集群线程模型分析",date:"September 28, 2022",path:"/2022/thread-model-of-rsync-based-distributed-file-system-helix-cluster",tags:["helix","distributed","rsync"],excerpt:""}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2022/Redis Commands.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Redis Commands 缩写",date:"September 21, 2022",path:"/2022/redis-commands",tags:["redis"],excerpt:""}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2021/一个安卓老用户换十三香之后的感受.md absPath of file >>> MarkdownRemark",frontmatter:{title:"一个安卓老用户换十三香之后的感受",date:"October 12, 2021",path:"/2021/iphone",tags:[],excerpt:""}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2020/为什么状态机在微服务架构下变得更重要.md absPath of file >>> MarkdownRemark",frontmatter:{title:"为什么状态机在微服务架构下变得更重要",date:"September 14, 2020",path:"/2020/state-machine-under-microservices",tags:["微服务","状态机","设计"],excerpt:""}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2020/如何打造一个serverless的微信小程序.md absPath of file >>> MarkdownRemark",frontmatter:{title:"如何打造一个serverless的微信小程序",date:"January 11, 2020",path:"/2020/how-to-build-a-serverless-wechat-mini-program",tags:["serverless","微信小程序","AWS","Anki","背单词"],excerpt:"本文介绍了一个完全serverless的应用开发过程以及所用技术的简单介绍。"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2019/Tokio Future.poll返回NotReady.md absPath of file >>> MarkdownRemark",frontmatter:{title:"自定义Tokio Future.poll返回NotReady",date:"March 01, 2019",path:"/2019/rust-tokio-futures-poll-not-ready",tags:["rust","tokio","Future","async programming"],excerpt:"如何在Future.poll中返回Async::NotReady"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2018/How To Read Rust API Doc.md absPath of file >>> MarkdownRemark",frontmatter:{title:"How To Read Rust API Doc",date:"June 01, 2018",path:"/2018/how-to-read-rust-api-doc",tags:["rust"],excerpt:""}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2018/简单比较下http2和http1.1的性能.md absPath of file >>> MarkdownRemark",frontmatter:{title:"简单比较下http/2和http/1.1的性能",date:"March 19, 2018",path:"/2018/simple-performance-comparison-between-http2-and-http1",tags:["http/2","测试"],excerpt:"简单对比http/1.1和http/2的性能"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2018/微服务架构下的开发环境问题.md absPath of file >>> MarkdownRemark",frontmatter:{title:"微服务架构下的开发环境问题",date:"March 16, 2018",path:"/2018/development-environment-for-microservices",tags:["微服务","架构","开发环境","microservices"],excerpt:"本文介绍如何在微服务架构下解决开发环境的搭建、共享的问题。"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2018/为Gatsby博客添加分页功能.md absPath of file >>> MarkdownRemark",frontmatter:{title:"为Gatsby博客添加分页功能",date:"March 12, 2018",path:"/2018/support-pagination-for-gatsby-blog",tags:["blog","gatsby"],excerpt:"根据Egghead上的教程，做出的博客站点有个缺陷，那就是没有分页功能，对于勤奋的博主来说，在一个页面上显示所有文章列表有点不完美，这里我们改造一下，加入分页功能。"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2018/为你的Gatsby博客添加评论功能.md absPath of file >>> MarkdownRemark",frontmatter:{title:"为你的Gatsby博客添加评论功能",date:"March 12, 2018",path:"/2018/enable-comments-for-gatsby-blog",tags:["blog"],excerpt:"Gatsby打造的博客已经很不错了，但是缺少一个评论功能。本文简单介绍如何集成Disqus评论服务到你的博客站点。"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2018/转用Gatsby搭建博客.md absPath of file >>> MarkdownRemark",frontmatter:{title:"转用Gatsby打造基于github的博客站点",date:"March 08, 2018",path:"/2018/blog-with-gatsby",tags:["blog","github","gatsby"],excerpt:"如何用Gatsby打造一个博客"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2018/一则奇怪的Toubleshooting.md absPath of file >>> MarkdownRemark",frontmatter:{title:"记一次奇怪的troubleshooting",date:"March 08, 2018",path:"/2018/skipper-sni-domain-fronting",tags:["skipper","SNI","domain fronting"],excerpt:"在Skipper转发请求到一个https站点的时候，返回莫名404."}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2016/JSON解析利器JQ.md absPath of file >>> MarkdownRemark",frontmatter:{title:"JSON解析利器---JQ",date:"March 25, 2016",path:"/2016/jq",tags:["bash","jq","json"],excerpt:"在API first的时代，json作为最常用的格式，充斥着程序猿的屏幕各个角落，掌握一门解析、过滤、转换json输出的工具，已经成为程序猿们安身立命的必要技能。 这里隆重向大家介绍[jq](https://stedolan.github.io/jq/)."}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2016/Function的协变.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Function的协、逆变",date:"February 04, 2016",path:"/2016/function-covariant-contravariant",tags:["scala","functional programming"],excerpt:"泛型编程的时候，协变(covariant)还是逆变(contravariant)很重要，在设计上层API接口的时候，正确的使用协变、逆变可以更好地约束程序员的行为，让实现变得安全、一致。"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2015/如何在Scala中实现AOP.md absPath of file >>> MarkdownRemark",frontmatter:{title:"用Mixin组合实现Scala中的AOP",date:"August 13, 2015",path:"/2015/aop-by-mixin-in-scala",tags:["scala","functional programming","AOP","mixin"],excerpt:"在Java世界，AOP（Aspect Oriented Programming， 面向方面编程)是很多框架的基础。这种将关注点按照“方面”来切分的编程模型极大地简化了编程的复杂度，尤其是在多维度因子交织在一起的时候的各种场景。对于代码的可读性、可维护性、可重用性都是极大的帮助。"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2015/Scala雾里看花.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Scala雾里看花",date:"April 23, 2015",path:"/2015/scala-trouble-shooting",tags:["scala","trouble shooting"],excerpt:"Scala的学习过程中，经常会碰到一些莫名其妙的现象，很多时候，这些语言层面的“怪象”都与scala编译器或者scala的类型系统有关。本文不是对编译器和类型系统的介绍，而是重点介绍遇到这些现象的时候，用什么样的方式，拨开云雾见蓝天，通过这些工具获取一些细节帮你了解编译器和类型系统如何工作。工欲善其事，必先利其器。"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2015/Docker创建MySQL主从复制以及CDC测试.md absPath of file >>> MarkdownRemark",frontmatter:{title:"MySQL Master/Slave Replication on Docker",date:"April 21, 2015",path:"/2015/mysql-replication-on-docker",tags:["docker","mysql"],excerpt:"How to setup Mysql master/slave replication."}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2014/Scala函数式异常处理.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Scala函数式异常处理",date:"May 04, 2014",path:"/2014/scala-error-handling-in-fp-style",tags:["scala","functional programming","exception handling"],excerpt:"经常看到很多示例代码，简洁的让人爱不释手，可是真正自己实现的时候，不得不添加各种各样的异常处理逻辑，最后发现代码总量的80%都是再做异常处理，而真正的代码逻辑只有很少的一部分。"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2014/高种泛型.md absPath of file >>> MarkdownRemark",frontmatter:{title:"高种泛型 (Generics of a Higher Kind)",date:"January 08, 2014",path:"/2014/generics-of-a-higher-kind",tags:["scala","functional programming","Generics"],excerpt:"Generics of a Higher Kind翻译加自我理解。"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2013/map-flatMap-for.md absPath of file >>> MarkdownRemark",frontmatter:{title:"map/flatMap/for in Action",date:"December 01, 2013",path:"/2013/map-flatmap-for",tags:["scala","functional programming"],excerpt:"前文说过了，高阶函数式函数式语言中的基石，而`map`, `flatMap`更是重要。"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2013/fold编程.md absPath of file >>> MarkdownRemark",frontmatter:{title:"折纸的艺术：fold编程",date:"November 27, 2013",path:"/2013/fold",tags:["scala","functional programming","fold"],excerpt:"Eric Meijer说：递归是函数式编程的GOTO，应该尽可能避免。如何避免，OO中我们用while循环，FP中我们用`fold`。"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2013/Monad.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Monad",date:"November 26, 2013",path:"/2013/monad",tags:["scala","functional programming","monad"],excerpt:"函数式语言与OO（确切地讲是指令式编程）的思维方式是完全不同的，很多OO中的经验在函数式语言中不是很匹配，比如设计模式，那就是一个OO中的特定术语，而在FP中，大家常谈的是对于习惯OO思维的程序员来说玄而又玄的Monad。"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2013/高阶函数.md absPath of file >>> MarkdownRemark",frontmatter:{title:"高阶函数",date:"November 21, 2013",path:"/2013/high-order-function",tags:["scala","functional programming","high order function"],excerpt:"所谓高阶函数（high order function），其实就是可以接受其他函数作为参数的函数。"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2013/Actor协调并发场景下的集合操作.md absPath of file >>> MarkdownRemark",frontmatter:{title:"边建边学-3：Actor协调并发场景下的集合操作",date:"November 17, 2013",path:"/2013/actor-collection-collabration",tags:["scala","functional programming"],excerpt:"很多时候为了提高性能，减少IO操作，都会将数据load出来之后缓存在内存中。本站的实现过程中也遇到类似的问题，不希望每次有人访问的时候就读取一次md文件，或者从MongoDB中查一次，而是直接在内存中读取。"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2013/Enumerator-Iteratee-Enumeratee.md absPath of file >>> MarkdownRemark",frontmatter:{title:"Enumerator / Iteratee / Enumeratee",date:"November 11, 2013",path:"/2013/enumerator-iteratee-enumeratee",tags:["scala","playframework","blog"],excerpt:"Stream对于指令式编程已经比较成熟了，有大量的类库，丰富的API。但是对于强调不可变量，尽可能无副作用的FP来说，要考虑语言适配的问题，而目前，流行的解决方案就是：Enumerator/Iteratee。"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2013/集成PlantUML和Markdown.md absPath of file >>> MarkdownRemark",frontmatter:{title:"边建边学-2：集成PlantUML和Markdown",date:"November 07, 2013",path:"/2013/markdown-plantuml-integration",tags:["markdown","plantuml","blog"],excerpt:"如何用Markdown+PlantUML结合来写图文并茂的博客。"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2013/EssentialAction-in-Playframework.md absPath of file >>> MarkdownRemark",frontmatter:{title:"EssentialAction in Playframework",date:"November 05, 2013",path:"/2013/essential-action-in-play",tags:["scala","playframework"],excerpt:"Playframework中EssentialAction理解"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2013/用markdown写博客.markdown absPath of file >>> MarkdownRemark",frontmatter:{title:"边建边学-1: 用Markdown写博文",date:"November 01, 2013",path:"/2013/blogging-with-markdown",tags:["markdown","blog"],excerpt:"本文将是一个系列文章，循序渐进地介绍本站的构建过程，不只是简单的技术介绍，重点是建站过程遇到的问题分析，以及解决的过程，所以起名**“边建边学”**系列。"}}},{node:{id:"/volume1/homes/leo/github/my-blog-code/src/pages/2013/开篇.md absPath of file >>> MarkdownRemark",frontmatter:{title:"开篇",date:"October 25, 2013",path:"/2013/start",tags:[],excerpt:"网络博客"}}}]}},pathContext:{group:[{node:{html:'<p>技术圈技术潮流真的是三十年河东，三十年河西。SOA不温不火N多年之后，换了个包装变成Microservice，就火了；之前很多RAD框架，很多DDD框架及产品也是很多年之后随着Low Code/No Code开始火了。Web圈感觉更是如此。服务端渲染框架如JSP在被以Angular, React, Vue等浏览器端渲染的SPA技术吊打多年之后，现在又逐渐开始有东山再起的苗头了。<a href="https://htmx.org/">HTMX</a>技术就是一个例子。</p>\n<p>其实这个技术本身也并不如何神奇，号称让任何html元素变成可ajax也不如何特殊，通过简单的javascript event callback机制都可以实现，不过HTMX采用声明式的定义，将需要用到Javascript的地方都用html element attribute来定义，就让一切变得不那么一样。看上去就像是一个纯静态的html</p>\n<pre><code class="language-html">&#x3C;div hx-post="/mouse_entered" hx-trigger="mouseenter once">\n    [Here Mouse, Mouse!]\n&#x3C;/div>\n</code></pre>\n<p>就是不知道将来会不会直接也变成一个新的HTML标准。</p>\n<h3>What HTMX Does</h3>\n<ul>\n<li>server side rendering</li>\n<li>empower any HTML element with the ability to send AJAX call (all HTTP methods)</li>\n<li>dynamically replace HTML of specified scope</li>\n</ul>\n<h3>Thymeleaf Template Engine</h3>\n<ul>\n<li>server side template engine</li>\n<li>Freemarker vs Velocity (markup tag based rather than plain text based?)</li>\n<li>layout :: fragment</li>\n<li>SpringMVC, return the <code>layout :: fragment</code></li>\n</ul>\n<p><a href="https://www.thymeleaf.org/doc/tutorials/3.0/thymeleafspring.html">https://www.thymeleaf.org/doc/tutorials/3.0/thymeleafspring.html</a></p>\n<h3>WebJars</h3>\n<ul>\n<li>wrap javascript libraries using Jars</li>\n<li>loading static assets???? </li>\n</ul>\n<h1>learning/web</h1>',id:"/volume1/homes/leo/github/my-blog-code/src/pages/2023/HTMX.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2023-09-19T14:30:25.000+08:00",path:"/2023/server-side-rendering-htmx",title:"新服务器端渲染Web技术：HTMX",excerpt:"",tags:["htmx","web"]}}},{node:{html:'<p>重要的思维方式：从什么角度看的问题</p>\n<p>怎么定义 <code>task</code>, 从全局的角度看，一个<em>task</em>，有下面两个基本属性：</p>\n<ul>\n<li>location 在哪个node上执行</li>\n<li>state 当前处于什么状态</li>\n</ul>\n<p><strong>task == resource, subtask == partition</strong></p>\n<p>所以，从Helix的角度，一个<em>task</em>也可以认为是一个<em>resource</em>，因为task和resource都有上面两个基本属性。</p>\n<p>一个<code>IdealState</code> /<code>CurrentState</code>也是对某个task/resource来说的。</p>\n<p><code>ZNRecord</code> : Zookeeper Node Record, generic的机制来存数据，类似Dao\n<code>HelixProperty</code>: Domain Object，其实就是封装了ZNRecord，并通过在Helix context有意义的方法。</p>\n<p>比如：</p>\n<ul>\n<li><code>HelixProperty.getBucketSize()</code> -> <code>ZNRecord.getSimpleField()</code></li>\n<li><code>CurrentState.getState()</code> -> <code>ZNRecord.getMapField().get("current_state")</code></li>\n</ul>\n<p>一个Task可以被拆分为小的subtasks，对应的，resource -> partition\n每个task/subtask可以有多个replica，以提高系统的可用性(availability)</p>\n<img src="https://mermaid.ink/img/Zmxvd2NoYXJ0IFRECiAgZGlyZWN0aW9uwqBMUgogIHN1YmdyYXBoIHRhc2sKICAgIFRhc2sgLS0+fHNwbGl0fCBTdWJUYXNrCiAgICBTdWJUYXNrIC0tPnwxLi5ufCBSZXBsaWNhCiAgZW5kCiAgZGlyZWN0aW9uwqBMUgogIHN1YmdyYXBoIHJlc291cmNlCiAgICBSZXNvdXJjZSAtLT4gUGFydGl0aW9uCiAgZW5kCiAgVGFzayAtLmFsaWFzLi0+IFJlc291cmNlCiAgU3ViVGFzayAtLmFsaWFzLi0+IFBhcnRpdGlvbg==" />\n<p>如下信息就是一个ZNRecord:</p>\n<pre><code class="language-json">{\n    "id": "myIndex",\n    "simpleFields": {\n        "NUM_PARTITIONS": "3",\n        "REPLICAS": "2",\n    },\n    "mapFields": {\n        "myIndex_0": {\n            "N1": "ONLINE",\n            "N2": "ONLINE"\n        },\n        "myIndex_1": {\n            "N2": "ONLINE",\n            "N3": "ONLINE"\n        },\n        "myIndex_2": {\n            "N3": "ONLINE",\n            "N1": "ONLINE"\n        }\n    }\n}\n</code></pre>\n<p>注意里面的<code>simpleFields</code>, <code>mapFields</code></p>\n<h3>State</h3>\n<p>不同的应用场景，每个node的状态是什么也不尽相同。Leader/StandBy, Online/Offline等等。每个node的状态机相应的也不同。Helix作为一个框架，就是要隔离这些不同，允许用户自定义状态机，以及状态转换的时候做的动作。</p>\n<p>注意：这里的状态特指每个Node的状态，不是业务逻辑里某个业务对象的状态。常见的状态机定义：</p>\n<ul>\n<li>\n<p>Leader / Standby</p>\n</li>\n<li>\n<p>Master / Slave</p>\n</li>\n<li>\n<p>Online / Offline</p>\n</li>\n<li>\n<p>Task/ScheduledTask</p>\n</li>\n<li>\n<p>StateModelDefinition (状态机定义)只描述整个状态机长什么样，有哪些状态，从哪个状态可以转换到另外的什么状态；但是定义里并不会具体说：转换的时候做什么事情（变的部分；不同的场景不同的处理）</p>\n</li>\n<li>\n<p>而StateModel（状态模型）才是声明状态转换的时候要做什么事情。所以，StateModel更像是个Callback的集合，<em>或者叫TransitionBehavior</em></p>\n</li>\n</ul>\n<h3>Spectator</h3>\n<p>每个node有自己的状态，整个cluster需要一个big picture，那就是ExternalView, 这个view会提供给观测者spectator，来监控cluster状态。</p>\n<h3>HelixAdmin</h3>\n<p>Helix cluster manager，通过这个manager可以创建cluster，获取cluster状态，获得cluster上的resource，创建新的resource. 开启maintenance mode.等等。</p>\n<p>创建一个HelixAdmin：</p>\n<pre><code class="language-java">HelixAdmin admin = new HelixAdmin.Builder()\n    .setZkAddress(zkSrv)\n    .build();\n</code></pre>\n<p>cluster manager可以定义cluster里有哪些状态机；List&#x3C;(clusterName, defName, def)></p>\n<h3>HelixManager</h3>\n<p>这个就是Helix Agent，在participant上面，那就是participant manager，在controller上面，就是controller manager. 任何需要和Helix交互的process都需要它。一般的流程是：</p>\n<pre><code class="language-java">manager = HelixManagerFactory.getZKHelixManager(clusterName, instanceName, ROLE, zkAddr);\nmanager.addPreConnectionCallback(cb);\nmanager.connect();\n....\nmanager.disconnect();\n</code></pre>\n<p>我们需要通过participant manager(HelixManager)来注册状态机工厂。</p>\n<pre><code class="language-java">participantManager.getStateMachineEngine()\n    .registerStateModelFactory(stateModelDefName, stateModelFactory);\n</code></pre>\n<p>Cluster里只有Participant node才有StateMachineEngine，其他controller，spectator都是null.</p>\n<h4>DefaultMessagingService</h4>\n<p>Helix Agent (manager)有一个消息服务，内置一个线程池 TaskExecutor. 只要agent connect到cluster之后，这个消息服务就会被初始化。</p>\n<h3>StateMachineEngine</h3>\n<ul>\n<li>Participant节点用<em>状态机引擎</em>注册<em>状态模型工厂</em></li>\n<li><em>状态模型工厂</em>创建<em>状态模型</em></li>\n<li><em>状态模型</em>处理状态转换消息。</li>\n</ul>\n<p>状态模型其实是我们日常说的状态机。</p>\n<h2>Questions</h2>\n<ul>\n<li>~~HelixAdmin.addStateModelDef vs HelixManager.getStateMachineEngine().registerStateModelFactory</li>\n<li>How does Helix dispatch jobs? via messaging?</li>\n</ul>\n<h1>Helix Recipes</h1>\n<h2>Distributed Lock Manager</h2>\n<p>基于zookeeper，但是能解决：</p>\n<ul>\n<li>第一个节点启动就取得所有lock的问题</li>\n</ul>\n<p>ZkClient.connect -> new ZkEventThread(维护一个BlockingQueue<ZkEvent>，这样ZkClient收到zookeeper的消息之后会发送ZkEvent到eventThread的blocking queue)\n-> ZkEventThread 会不停地循环，从blocking queue里获取event之后event.run\n-> event是一个匿名类</p>\n<p>ZkClient是一个ZooKeeper的Watcher实现,  ZkClient.process(WatchedEvent) 会调用各种listener.</p>\n<p>CallbackHandler.handleChildChange -> enqueTask -> invoke ->\nHelixTaskExecutor.onMessage -> scheduleTask (提交任务到线程池) <del>-</del>>\nHelixTask.call ->\nHelixStateTransitionHandler.handleMessage -> invoke (根据StateModel class里方法上Annotation from，to找到对应的method，然后反射地调用。)</p>\n<p>ZKHelixManager.connect -> createClient (初始化ZkClient) -> zkClient.subscribeStateChanges</p>\n<h1>learning/framework/helix #open-source</h1>',id:"/volume1/homes/leo/github/my-blog-code/src/pages/2023/Helix Notes.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2023-09-19T14:20:21.000+08:00",path:"/2023/helix-concept-model",title:"Helix概念模型",excerpt:"",tags:["helix","apache","distributed"]}}},{node:{html:'<h2>摘要</h2>\n<p>根据文中提到,团队拓扑定义的四种团队类型和三种协作模式如下:</p>\n<p>四种团队形式:</p>\n<ul>\n<li>面向流团队(Stream-aligned team):负责单一业务能力的软件开发团队。</li>\n<li>平台团队(Platform team):构建内部平台以集成各种服务的团队。</li>\n<li>使能团队(Enabling team):由专家组成的团队,通过培训和指导帮助其他团队。</li>\n<li>复杂子系统团队(Complicated-subsystem team):专注于复杂子系统的团队。</li>\n</ul>\n<p>三种团队交互模式:</p>\n<ul>\n<li>X即服务模式(X-as-a-Service mode):平台团队向面向流团队提供平台服务的模式。</li>\n<li>协作模式(Collaboration mode):团队之间进行密集合作的模式。</li>\n<li>促进模式(Facilitating mode):使能团队通过培训和指导帮助其他团队的模式。</li>\n</ul>\n<h2><a href="https://martinfowler.com/bliki/TeamTopologies.html">原文</a>翻译（by Claude)</h2>\n<p>任何大型软件项目,例如大公司的软件系统,都需要大量人员参与,在有大量人员参与时,你必须要考虑如何将他们划分成高效的团队。<code>基于业务能力</code>的团队划分有助于软件项目对客户需求作出响应,但是所需技能范围的广泛会让这样的团队不堪重负。<code>团队拓扑</code>是 Matthew Skelton 和 Manuel Pais 开发的用于描述软件开发团队组织的模型。它定义了四种形式的团队和三种团队交互模式。该模型鼓励健康的交互,使基于业务能力的团队得以在持续提供有价值软件的任务中蓬勃发展。</p>\n<p>在该框架中主要的团队形式是<code>面向流的团队</code>,这是负责单一业务能力软件的<em>基于业务能力</em>的团队。这些是长期存在的团队,将他们的工作视为为增强业务能力<em>提供软件产品</em>。</p>\n<p>每个面向流的团队都是全栈(front-end、back-end、数据库)和全生命周期(业务分析、功能优先级确定、用户体验、测试、部署、监控等软件开发环节),他们<code>注重业务成果</code>(结果导向）而不是以<code>功能导向</code>(如业务分析、测试或数据库，原文是Activity Oriented)。但他们也不应该过于庞大,理想情况下每个团队都是一个能用两份比萨饱腹的小团队。大型组织会有许多这样的团队,尽管他们支持不同的业务能力,但都有一些共同需求,如数据存储、网络通信和可观察性。</p>\n<p>像这样小的团队需要方法来减少他们的认知负荷,因此他们可以专注于支持业务需求,而不是(例如)数据存储问题。实现这一点的重要方法是在一个可处理这些非关键关注点的平台之上进行构建。对许多团队来说,广泛可用的第三方平台(如面向数据库 Web 应用程序的 Ruby on Rails)可以作为一个平台。但是对于许多产品来说,没有现成的平台可供使用,团队需要找到并集成多个平台。在较大的组织中,他们需要访问一系列内部服务并遵循企业标准。</p>\n<p>这个问题可以通过为组织构建内部平台来解决。这样的平台可以将第三方服务、近乎完整的平台和内部服务进行集成。团队拓扑将构建这一平台的团队(不够生动但明智的)归类为<code>平台团队</code>。</p>\n<p>较小的组织可以使用单个平台团队,它在一个外部提供的产品集之上制造一个薄层。然而,较大的平台需要的人数超过两份比萨可以喂饱的人数。因此作者进一步描述了由多个平台团队组成的<code>平台分组</code>。</p>\n<p>平台的一个重要特性是它被设计成可以主要以自助的方式使用。面向流的团队仍然负责他们产品的运营,并直接指导他们对平台的使用,而不期望与平台团队进行精心协作。在团队拓扑框架中,这种交互模式被称为 <code>X 即服务模式</code>,平台充当面向流团队的服务。</p>\n<p>然而,平台团队需要将他们的服务构建为产品,并深入理解客户的需求。这通常需要他们使用不同的交互模式,即<code>协作模式</code>,同时构建该服务。协作模式是更密集的合作伙伴形式的交互模式,应被视为一种临时方法,直到平台足够成熟以转向 X 即服务模式。</p>\n<p>到目前为止,该模型没有代表任何特别新颖的思想。企业软件存在以来,就有将组织分解为业务相关团队和技术支持团队的方法。近年来,许多作者强调让这些业务能力团队负责完整的技术栈和完整的生命周期的重要性。对我来说,团队拓扑的亮点是它关注这样的业务相关团队是完整的技术栈和全生命周期管理,这意味着它们往往面临过高的认知负荷,这与希望拥有小型、敏捷团队的愿望相矛盾。平台的关键优势在于它<code>减少了这种认知负荷</code>。</p>\n<p><strong>团队拓扑的关键洞察力在于平台的主要优势在于它减轻了面向流团队的认知负荷。</strong></p>\n<p>这一洞见具有深远的意义。首先,它改变了平台团队应如何考虑平台。减轻客户团队的认知负荷会导致不同于主要用于标准化或降低成本的平台的设计决策和产品路线图。再者,这个洞察引导团队拓扑通过识别另外两种团队类型来进一步发展他们的模型。</p>\n<p>一些功能需要专家,他们可以投入大量时间和精力掌握许多面向流团队都重要的主题。安全专家可以花费比作为面向流团队成员更多的时间学习安全问题并与更广泛的安全社区进行互动。这些人聚集在<code>使能团队</code>中,其角色是在其他团队中培养相关技能,以使这些团队保持独立并更好地拥有和发展其服务。为了实现这一点,使能团队主要使用团队拓扑中的第三种最终交互模式。<code>促进模式</code>（这个翻译不错，点出了facilitating的目的）涉及指导角色,使能团队不会编写和确保遵循标准,而是教育和指导他们的同事,使面向流团队变得更具自主性。</p>\n<p>面向流团队负责为其客户提供整个价值流,但我们偶尔会发现面向流团队的某些工作非常具有挑战性,以至于需要一个专门的团队来关注它,这导致第四种也是最后一种团队类型:复杂子系统团队。复杂子系统团队的目标是减轻使用该复杂子系统的面向流团队的认知负荷。即使只有一个客户团队,这也是一个值得的划分。复杂子系统团队主要努力与客户使用 X 即服务模式进行交互,但会需要在短时间内使用协作模式。</p>\n<img src="https://martinfowler.com/bliki/images/team-topologies/diagram.png" width="650">\n<p><em>团队拓扑包括一组图形符号来说明团队及其关系。这里显示的图标来自<a href="https://github.com/TeamTopologies/Team-Shape-Templates">当前标准</a>,与书中使用的不同。<a href="https://teamtopologies.com/key-concepts-content/team-interaction-modeling-with-team-topologies">最近的一篇文章</a>详细阐述了如何使用这些图表。</em></p>\n<p>团队拓扑是明确认识到<code>康威定律</code>的影响而设计的。它鼓励的团队组织方式考虑到人员和软件组织之间的相互影响。团队拓扑的拥护者希望其团队结构可以塑造软件架构的未来发展,使其成为响应业务需求的解耦组件。</p>\n<p>乔治·博克斯巧妙地指出:“所有模型都是错误的,有些是有用的”。因此团队拓扑是错误的:复杂的组织不能简单地分解成仅四种团队和三种互动。但是这种约束使模型变得有用。团队拓扑是一个工具,促使人们将组织发展为一种更高效的运作方式,这种方式能够通过减轻认知负荷最大限度地提高面向流团队的效率。</p>\n<h2>思考</h2>\n<ul>\n<li>我们公司中有Enabling Team吗？或者说本应承担这些角色的团队是这样和其他团队交互的吗？</li>\n<li>复杂子系统团队是否应该是短期的？随着项目的结束也结束？那么以后这些复杂子系统如何维护？</li>\n<li>平台团队需要面向客户吗？或者说，我们需要真正面向内部的平台团队，而不是面向客户、提供基础服务的功能团队？</li>\n<li>同时面向内部和外部客户的平台团队合理吗？</li>\n</ul>',id:"/volume1/homes/leo/github/my-blog-code/src/pages/2023/团队拓扑.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2023-08-25T13:39:15.000+08:00",path:"/2023/team-topologies",title:"团队拓扑",excerpt:"",tags:["team","platform","management"]}}},{node:{html:'<p>本文为chatGPT翻译稿，原文参见：<a href="https://queue.acm.org/detail.cfm?id=3595860">https://queue.acm.org/detail.cfm?id=3595860</a></p>\n<hr>\n<p>“思考科学问题的能力是智力的定义本质吗？”——艾德琳·V·莱文</p>\n<p>物理学家卡尔·萨根曾经写道：“科学不仅仅是一种知识体系；它还是一种思维方式。”这种思维方式需要怀疑的严谨和残酷的诚实，以彻底调查、推理和试图证伪假设，而不是草率地下结论。但是，人们很容易做出决策。尽管我们自称聪明，但人类很容易相信基于少量相关信息的显著谬误，而不是严格寻求确定因果基础。 </p>\n<p>这种人们如此轻易相信奇妙、奇幻事物的倾向，正是另一位物理学家理查德·费曼所称的船货崇拜科学。费曼以太平洋岛屿上的一群“船货崇拜”者来命名这种现象，他们相信在第二次世界大战后，建造着陆道和控制塔的复制品可以确保补给飞机继续着陆。然而飞机从未来过。这些人忽略了一个事实，即是战争的爆发，而非着陆道的存在，导致飞机在那里着陆。 </p>\n<blockquote>\n<p>wiki: 货物崇拜（英文：Cargo Cults，又译货物运动）是一种宗教形式，特别出现于一些与世隔绝的原住民中。当货物崇拜者看见外来的先进科技物品，便会将之当作神祇般崇拜。</p>\n<p>最为知名的货物崇拜，是瓦努阿图塔纳岛的「约翰布鲁姆教」（John Frum Movement）。第二次世界大战太平洋战争时，美军于塔纳岛创建一临时基地。当时岛上的原住民看见美军于「大铁船」（军舰）内出来，皆觉得十分惊讶。此外，他们也看到，有一些「大铁鸟」（军用飞机）运送穿着美军军服的人及许多物资。这些原住民看见这种情况均感到很惊讶，并觉得这些「大铁船」及「大铁鸟」十分厉害。加上美军也提供部份物资给原住民，而这些物资对原住民来说十分有用，结果令这些原住民将美军当作神。</p>\n</blockquote>\n<p>如今，有人推测，如GPT-4等大型语言模型（LLM）可以看作是通用人工智能（AGI: artificial general intelligence）的早期版本。与任务特定的人工智能（AI）不同，AGI被认为能够执行人类可能能够完成的任何一般任务。认为LLM是新兴AGI的观点令人不安。LLM展示了许多智能行为和原则，但缺少一些基本的东西：<strong>科学探究的严谨</strong>。如今的AI模型缺乏抽象思维能力，包括问答中的“为什么？”和“如何？”。 </p>\n<p>科学思维能力是智能的决定性本质吗？事实上我们并不知道。目前还没有一个全面的理论来解释智能是什么，或者它是如何从基本原则中涌现出来的。然而，显然，如今的LLM尚不能复制科学思维，这使人们能够结合培根的经验主义和笛卡尔的理性主义，扩大科学理论的可证伪知识领域。科学研究方法使人类能够确定普遍性、非决定性和因果性等方面，从而最终实现操纵自然世界，推动人类福祉的发展。 </p>\n<p>有证据表明，人类大脑并非天生就具有科学思维能力，然而，它可以被教会如何这样做。相信UFO、ESP以及社交媒体上传播的任何东西的船货崇拜现象广泛存在，这种现象和萨根、费曼等科学巨匠共用一个物种。如今的尖端LLM也不是天生具有科学性。但与人类大脑不同，有充分理由相信，除非发展新的算法范式，否则他们永远无法实现这一目标。 </p>\n<h2>一种主导的算法范式</h2>\n<p>人工智能领域取得了可观的进展，包括最近引起轰动的ChatGPT，这些进展主要归功于一种称为多层（或深度）神经网络的机器学习方法的成功。这种方法在20世纪40年代被发明，几乎所有神经网络（网）的基本概念以及相关方法（包括卷积神经网络和反向传播）都在20世纪80年代就已经存在了。然而，直到大规模数字数据集和足够快的GPU（图形处理器单元）硬件出现才开始出现使用神经网络的应用。 </p>\n<p>神经网络在当今人工智能领域的主导地位归功于它们惊人的突现能力。神经网络是一种数学函数，提供经验信息的表示，并为给定输入计算输出。神经网络的数学形式是加权有向图，顶点称为神经元，边称为连接。对于模型如GPT-3，它有1750亿连接，因此有1750亿个权重，函数将有数十亿个术语。 </p>\n<p>神经网络的权重和偏差是通过称为深度学习的过程来确定的，该过程使用反向传播算法逐步降低模型预测和训练数据之间的误差。训练后的神经网络模型有效地将训练数据转化为抽象表示，抑制无关信息并放大或扭曲分类所必需的特征。这些抽象表示最初用于实现各种各样的输入数据的分类，但也可以用于生成。今天，AI模型能够生成从聊天提示到图像的任何东西（例如，由生成对抗网络生成的图像）。这些生成任务背后的转换器模型，例如LLM GPT-3，仍然使用神经网络的基本架构，并增加了注意力来通过跟踪序列数据中的关系来学习上下文。 </p>\n<p>因此，使用神经网络进行深度学习已被证明是一种强大而灵活的计算框架。然而，如果目标是实现具有科学推理能力的AGI，这种方法最终可能会停滞不前。神经网络可能在建立普适性、非确定性或因果推理等方面本质上无法实现某些事情。即使是它们所能做的事情，神经网络也需要消耗极高的资源。在通往AGI的道路上，这种方法真正能够取得多大的改进，而且是否真的可持续？</p>\n<h2>从富裕时期到匮乏时期</h2>\n<p>摩尔定律推动的计算能力和存储容量的显著增加，推动了数据语料库的爆炸，使得深度学习等资源密集型方法成为可能。例如，谷歌BERT（双向编码器表示转换）的训练需要33亿个令牌和40多个训练周期。与此相比，一个普通孩子在5岁之前可能听到4500万个单词。这相当于BERT的3000倍之差，也远远不及培训GPT-3可能使用的数百亿个令牌。 </p>\n<p>今天的数据和资源丰富与计算时代的基础算法工作形成了鲜明的对比，当时的创新是基于匮乏的。计算存储和处理能力非常有限且非常宝贵，因此需要新的算法方法来解决在低效的蛮力方法不可能解决的情况下的问题。 </p>\n<p>实现AGI可能需要重新回到这种匮乏的思维模式，设计新的算法方法，可以极大地节省信息处理和抽象模型生成。训练越来越大的神经网络所需的成本和能源消耗的飙升不太可能是可持续的，并且将需要这种转变。如今的大型AI模型的成本可能达数千万美元，并且每年消耗太瓦小时的能源。与之相比，人脑消耗的能量微不足道。 </p>\n<p>好消息是，今天的AI模型中的数据表示可能远非实现某种能力所需的最小算法表示，因此还有充足的空间进行基于匮乏的算法创新。 </p>\n<p>即使解决了这个资源问题，AI基本限制中仍存在无法科学思考的问题。除非引入基本算法创新来使AI能够提出和回答“为什么”的问题，否则当前的方法将无法实现AGI。</p>\n<h2>模型的普遍性——还是缺乏普遍性？</h2>\n<p>神经网络是一种模型。它们提供了一个计算结果的数学过程，而不是直接测量结果。人类已经发展了数个世纪的模型来帮助预测和理解，并最终提高生产率。不需要每次需要特定信息，如火箭的轨迹或电容器中的储存能量时进行测量，通常可以确定一个数学过程，从而实现准确的预测结果。 </p>\n<p>开发这样的预测模型是理论科学的基础。数学模型的成功通常取决于其预测性的普适性。具体来说，开发用于预测一种现象的数学过程在多大程度上能够成功预测完全不同类别的现象？ </p>\n<p>举个例子，考虑开发一个预测行星运动的模型，这是17世纪天文学家约翰内斯·开普勒探讨的问题。开普勒通过仔细研究来自天文学家泰科·布拉赫的详细天文观测数据，创造了他著名的行星运动三定律。这三定律普遍描述了太阳系中行星的轨道形状，速度和周期，基于其距离太阳的距离。虽然这些结果可以推广到其他行星系统或其他轨道体（卫星，人造卫星等），但它们不能转化为非轨道引力现象。艾萨克·牛顿在机械理论和引力理论方面的突破才能发展出一个统一的数学框架，以描述行星运动和苹果从树上掉落的运动。 </p>\n<p>因此，牛顿的方法比开普勒的方法更具有普适性，但这并不是全部。有些物理情境下，牛顿模型会失效。20世纪初的突破，包括爱因斯坦对广义相对论的研究和量子力学理论的发现，提供了更普适的方法来预测不同领域的物理现象。这些数学模型可以用来准确地预测会发生什么，跨越比牛顿模型涉及的问题领域更广泛的范围。 </p>\n<p>AI使用的神经网络模型有多普遍？并不是很普遍。神经网络的预测仅适用于训练中涉及的情况。如果不包括足够不同的情况作为训练数据，AI将无法进行准确的预测。AI的生成能力也受限于培训场景的范围。 </p>\n<p>考虑一个训练了布拉赫天文数据的神经网络；结果将是一个能够预测已知行星相对于地球参考系位置的AI模型，但不可推广到其他坐标系，其他天体或其他行星系统。行星运动的AI模型不仅比开普勒的模型更少普适性，而且无法通过提出行星为什么会运动的问题来朝向增加普适性的方向发展。</p>\n<h2>不同类型的模型</h2>\n<p>值得注意的是两种类型的模型之间的主要区别：人工智能中使用的模型与理论物理中遇到的模型。 </p>\n<p>人工智能模型完全是由数据驱动，使用数学函数——神经网络的函数——来编码大型数据集的抽象表示。 </p>\n<p>理论物理中通常发现的模型，如牛顿力学，是观察到的物理现象的概括。这样的模型以微分或积分方程的形式书写，通过科学方法进行严密的假设测试，以确定其在相关领域内的通用性。这些方程的解决方案往往需要计算强度，需要使用正式的数学方法来精确解决。这些模型还通过描述潜在的数据生成过程来建立因果推断——我们将回到这个主题——。 </p>\n<p>为什么如果它的模型是数据驱动的而不是通用的，人工智能会变得如此有用呢？人工智能似乎特别适合的任务，如图像识别和写作文章，是人类大脑也熟练掌握的任务的一个子集。或许这并不令人惊讶，因为神经网络是受到大脑中神经元突触网络的启发产生的。神经网络已被证明在模拟人类行为方面非常出色，这是一个实验结果——并不基于任何理论基础。没有简单的科学理论来解释人脑实际上是如何工作的，因此无法证明为什么人工智能在模仿大脑能力方面表现得如此出色；但是，当涉及建模这些人类掌握的任务时，还没有更好的替代方案。 </p>\n<p>这里的一个关键点是，无论是人工智能模型还是物理模型，都不能被称为智能。使人类智能与今天的人工智能不同的是其能力：提问为什么，从第一原则出发进行推理，并创建实验和模型来测试假设。真正的人工智能应该做到同样的：开发越来越复杂的模型，以像人类一样普遍地解释现象。这将是远离复制人类船只崇拜行为，对于人工智能的期望目标。</p>\n<h2>不确定性</h2>\n<p>考虑到普适性，还有另一个问题：如果您将所有在宇宙中产生的数据都提供给人工智能，那会怎样？一定有足够大的神经网络能够做任何事情。不幸的是，即使您不知道如何收集、存储和处理所有这些数据，这也是行不通的。这种理想的、数据驱动的超级智能是由数学家皮埃尔-西蒙·拉普拉斯于1814年提出的，但经过20世纪的科学发展已经被证明是不可能实现的。 </p>\n<p>主要原因是宇宙中内在的不确定性，在量子力学领域被发现。古典动力学理论中的混沌系统的额外发现也提出了一个问题：即使初始条件中有微小的扰动，也可能导致截然不同的结果，需要无限精度的测量来进行数据采集。 </p>\n<p>最后，逆问题[见侧栏：人工智能能听到鼓的形状吗？]也提出了另一个挑战：即使有关系统的所有相关数据都可用，也不可能确定其原因，由于非唯一性和从正向问题到逆向问题的信息丢失。 </p>\n<p>量子力学系统和混沌系统是科学家已经确立了一些因果链的两个例子，但具体的结果无法预测。可以编写一个微分方程，以确定性地预测粒子概率振幅的动态演化，但在实际测量之前无法确定可观察量，例如粒子的位置。同样，可以写出混沌系统的控制方程，例如双摆的方程，但在没有精确的初始条件和直接计算的情况下，无法预测其在以后的时间的位置。 </p>\n<p>自然界中充满了这样的例子，意外可能发生，这是由于内在的不确定性所致。通过纯经验方法确定这些现象背后的原因是不可能实现的。</p>\n<h3>侧栏：人工智能能听到鼓的形状吗？</h3>\n<p>我最近开始询问那些来面试研究职位的候选人，是否可能听到一个鼓的形状。这个看似无害的问题是由数学家马克·卡克在1966年提出的，困扰了数学界数十年。 </p>\n<p>我经常得到的快速答案是：“当然可以听到鼓的形状。只需要一个足够大的与鼓面形状相关的声音数据集（用于监督学习），或者甚至不用关联形状（用于非监督学习），并使用有效的训练算法和验证方法。一旦模型被训练好了，它将从任何给定的记录频谱中推断出鼓的形状。” </p>\n<p>这个答案是错误的，这就是为什么卡克著名的问题值得在今天的人工智能背景下解决复杂问题的原因。在20世纪90年代，数学家们最终证明了听到鼓的形状是不可能的，或者至少不是唯一的。这是因为存在形状不同但产生完全相同声音的鼓面，或者在数学上说，是等谱的。数学家们通过研究Helmholtz方程边值问题中得出的洞见，来回答卡克的问题，该方程描述了鼓面的运动。卡克的问题的答案不能仅通过对频谱数据的经验分析来解决。 </p>\n<p>机器学习模型如何处理一对具有不同形状但等谱的鼓面？如果训练数据中包含两种形状的频谱，则在采用有标签的监督学习方法时，模型有有限的可能性得到正确答案。但如果训练中只包含一种形状的频谱，并使用另一种形状的频谱进行推断，则模型会给出错误的预测鼓形状的结果。也许我们应该警惕，并将所有等谱鼓面形状包含在训练集中？那么我们面临的问题是如何事先知道有多少这样的形状。我们必须返回到抽象的数学推理中。 </p>\n<p>对于熟悉逆问题的人来说，卡克的鼓只是一个例子，这些观察结果并不令人惊讶。逆问题试图使用观察到的数据来确定产生数据的因果因素。在振动鼓的情况下，纯经验主导的数据驱动方法只能提供部分理解。然而，随着数据驱动的机器学习的强大工具的不断提高，所有问题都开始看起来像钉子。从分析方法中获得的强大见解被忽视了，这在许多面试候选人中经常发生。 </p>\n<p>虽然大多数候选人答错了这个问题，但他们可以快速学习如何全面地探索逆问题的解决空间。相反，人工智能并不是一种通用智能，它不知道如何问出和回答鼓面谱是什么，是否可能有等谱的鼓，如果有，有多少。人类可以接受培训，提出这些问题，并使用人类已经开发的严谨科学和分析方法，得出全面可证伪的假设作为答案。人工智能还没有达到这个水平。</p>\n<h2>因果推断</h2>\n<p>那么，在可以建立因果关系的情况下呢？即使在这种情况下，AI也不会成功地回答为什么。当前基于神经网络的AI无法推断有关数据生成过程的特征，因此无法建立因果推断。通过科学假设测试和使用反事实逻辑做到这一点，并不在神经网络的范围之内，仍然是人类行为的一个特征，AI尚未能够实现。 </p>\n<p>需要注意的是，人类可能会错误地在因果关系的语境中使用AI，而实际上不存在因果关系——有效地加剧了人类船货崇拜的创造。这是因为神经网络非常擅长识别数据集中的相关性。然而，任何具备基本统计培训经历的人都知道，相关性并不意味着因果关系。存在许多重要的例子，显示出数据相关性映射到虚假因果链的关系，如鸟嘴鸟数量和人类出生率之间的关系以及气候变化的出现是由于海盗数量下降的结果。 </p>\n<p>在关键时刻需要建立因果推断的场景中使用AI的相关能力越来越普遍。一个重要的例子是在确定医学诊断方面应用AI。需要注意的是，在将神经网络委托决策建立在建立因果关系的基础上的情况下（如根据症状确定疾病），特别是当人类生命处于危险之中时，应该谨慎对待。如果用作医生分析数据的辅助工具，在临床环境中，AI可以极大地有益——只要人类医生自身接受过保持独立推理、假设测试和决策制定的培训。AI的输出应被视为一个潜在有益的相关性指标，而不是被视为因果命令。</p>\n<h2>人工智能与人类的交互：增强还是削弱人类智能？</h2>\n<p>为什么人类决策者的独立思考如此重要？除了无法建立因果关系外，AI的输出也无法解释，有时完全毫无意义。这并不是说我们不知道AI如何工作。原则上，可以追踪神经网络为给定输入所做的每个计算，以了解其是如何得出答案的。然而，如今神经网络的规模之大不仅使这种方法不切实际，而且实际上毫无意义，这导致了神经网络的黑箱功能的印象。 </p>\n<p>同样，即使训练算法易于理解，任何给定权重具有特定值的原因也是不可推导的。数十亿个权重是通过许多培训时期与庞大的可选数据库确定的。因此，针对相同任务设计的神经网络，如果经过不同的训练，可能会产生不同的行为，导致权重不同。 </p>\n<p>AI错误和误分类的例子比比皆是。其中一些例子旨在阐明确定错误输出的原因之难。例如，如果像向量梯度那样设计了似乎是噪音的图像添加到图像中，这可能会导致错误的分类，因为它在高维决策边界上跨越了神经网络。 </p>\n<p>在其他情况下，AI分类是错误的，因为它所训练的数据中存在人为干扰。临床情境中的例子包括一个神经网络，它被训练用于在胸片上检测肺炎，但在测试从其他医院的X射线成像系统收集的数据时性能严重下降。这种退化是由于这些其他X射线成像系统图像人为干扰的差异造成的。AI模型还学会了将不相关的特征，如放置在X射线前的病人的金属代币，与疾病发生相关联。 </p>\n<p>如今的转换器模型旨在超越以往的方法，开发AI用于定制应用，如肺炎检测AI模型。 LLMs是领先的例子。这些模型提供了一种新的AI范例，利用迁移学习将一个庞大的模型应用于各种不同的任务。然而，这些基础转换器模型（也称为基础模型）引入了新的风险：所有派生自少数转换器模型的下游AI系统都将继承这些父转换器模型的任何错误或有问题的偏见。 </p>\n<p>还有一些没有意义的转换器模型输出，如ChatGPT的“幻觉”。例如，当询问巨大血管瘤患者是否可以服用抗凝剂时，ChatGPT不仅给出了错误的答案，与所有临床指标相矛盾，因此可能对患者构成致命危险，而且还创建了假冒引文来支持其主张。 </p>\n<p>这不仅令人不安，而且会成为误用AI的明显例子，如果这样的回应应用于临床环境中。 ChatGPT不是设计为提供事实上的正确答案。它被设计为按顺序选择最有可能跟随一串单词的令牌，以与人类语言的句法一致的方式排列一组单词。有意义的答案的有些是统计概率的结果，即在语法正确的段落中实际包含可验证的正确信息的概率。将这种类型的错误输出称为幻觉是不恰当的。这些响应不是由于模型的预期行为出现错误，而是由于模型本身的基本限制造成的。 </p>\n<p>尽管存在这些限制，AI将继续被采用用于人类使用，不可避免地，人类认知将作出相应的调整。最近的历史已经显示，人类会对新技术做出认知调整。互联网搜索引擎的出现改变了人类的回忆，使其更多地权重信息来源而不是信息本身。将AI纳入工作流程中提高人类生产力不应取代独立人类理性的培训和提高。否则，我们的社会可能会出现新的人类船货崇拜热潮。</p>\n<h2>对思维的反思：通向AGI的道路？</h2>\n<p>训练一个足够大的神经网络来模拟大部分人脑所能做的事情可能是有可能的。最近神经网络在图像字幕和文章写作等人类类似任务中的成功表明，大脑的处理或许并不像曾经想象的那样计算困难。这个结果本身可能是一个科学突破。 </p>\n<p>然而，这样的进展并不意味着我们已经完成了实现AGI所需的工作。需要新颖的算法方法来超越纯经验推理的边界，包括科学思维所需的抽象推理、假设测试和反事实逻辑。还需要一种稀缺心态，以实现算法效率，使未来的AI系统能够可持续地消耗资源。 </p>\n<p>尽管存在挑战，但仍有巨大的乐观主义理由。AI和AGI研究提供的最激动人心的机会之一是理解人类思维和智力的一个最大未解决科学问题。迄今为止，没有科学理论能够解释人类的思维方式以及原因。 </p>\n<p>最后值得问的问题是AGI是否真的有可能实现。如果AGI被定义为与人类相等的智能，那么答案必须是肯定的。人脑的存在本身就表明，应该有可能将物质配置成与人一样聪明的形式。但是否AGI真的是一个值得追求的目标还无法确定，因为缺少全面的科学理解关于人类智力的构成。形成类似于船货崇拜的行为绝对不是一个值得模仿的行为，但为什么人类却会这样做还是一个未解之谜。 </p>\n<p>也许人类大脑本质上是有点懒惰的。对于人类来说，通过科学的推理和思考解决问题需要特殊的、集中的精力。人类认知的默认懒惰可能是演化压力选择高效能量支出的结果，因为大脑是一个重要的能量消耗者。在寻求创造能够复制人类大脑能力的AGI之前，这些假设应该得到回答。否则，在未来的某个时候，我们将不仅拥有人类的船货崇拜，还将拥有AGI的船货崇拜。</p>',id:"/volume1/homes/leo/github/my-blog-code/src/pages/2023/Cargo Cult AI： 船货崇拜AI.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2023-05-16T12:30:12.000+08:00",path:"/2023/cargo-cult-ai",title:"Cargo Cult AI： 船货崇拜AI",excerpt:"",tags:["LLM","AGI","ChatGPT"]}}},{node:{html:'<h1>Stable Diffusion Prompt技巧</h1>\n<p>最近生成类AI技术火热，编程有Github Copilot, 文字转图片有Stable Diffusion。我自己已经用上了Copilot，感觉还是挺有用的。</p>\n<p>周末尝试了一下Stable Diffusion，刚开始感觉这个东西就是个黑魔法，用文字描述你想画的东西，AI就能帮你生成图片。可怎么能生成好看的图片呢？除了一堆搞不懂的调节参数，你好像能控制的只有输入的文字了。</p>\n<p>对于普通用户，你只能不断地试各种输入，不明就理地无脑乱撞。由此，还诞生了个新名词：Prompt Smithing，我自己翻译成了“提词匠”。一定意义上，人就变成了AI助理，我们完全没有掌控能力。</p>\n<p>基于目前机器学习的原理，底层具体是怎么工作的，确实是个黑盒子，很难预测其行为（反过来说，如果我们能准确预测其行为，也就不需要机器学习了），只能不断尝试。不过，懂一些基本的工作原理还是能帮助我们提高效率和准确率的。</p>\n<h2>工作原理</h2>\n<p>Stable Diffusion能画画的原理来源于其学习方式：从互联网上抓取海量的“图片-标题”信息，识别后将其归类进一个“超维空间”。不同的关键词周围有大量的该关键词的图片，从一个关键词移动到另外一个关键词，图片的内容会逐渐向目标关键词演化。</p>\n<p>“trending on artstation"能起作用的原理，就是因为在"artstation", "flickr"等网站上的照片都比较好看，所以我们生成的图片应该尽量靠近这些关键词周边的图片。</p>\n<p>"Octane Render"(显卡渲染，一家新西兰公司的技术)之所以能起作用，也是因为该公司以3d渲染高画质闻名。</p>\n<p>不同的画里面关键词的权重也不同，强权重的关键词会冲淡弱关键词的效果。</p>\n<p>提词出现的顺序也有一定关系。参照上面的原理，提词顺序可能代表不同的路径。</p>\n<p>很多时候，关键字和图片的关联关系不一定是有意义的，也可能只是因为习惯或者由于机器抓取图片标题时，对标题的错误解析，导致AI误以为某些关键词和图片有关联。比如中文标点符号“，”和图片水印。所以，如果遇到这个问题就得把逗号等作为negative prompt过滤掉。</p>\n<h2>最佳实践</h2>\n<p>提词应该带有下面的内容：</p>\n<ol>\n<li>画面主题描述</li>\n<li>风格，比如油画，概念画等等</li>\n<li>艺术家，比如梵高，毕加索等</li>\n</ol>\n<h2>参考资料</h2>\n<ul>\n<li><a href="https://github.com/IDEA-CCNL/Fengshenbang-LM/blob/main/fengshen/examples/stable_diffusion_chinese/taiyi_handbook.md">AI人类助理</a></li>\n<li><a href="https://www.howtogeek.com/833169/how-to-write-an-awesome-stable-diffusion-prompt/">How to write an awesome stable diffusion prompt</a></li>\n<li><a href="https://huggingface.co/stabilityai/stable-diffusion-2">Stable Diffusion 2</a></li>\n<li><a href="https://huggingface.co/spaces/Gustavosta/MagicPrompt-Stable-Diffusion">Magic Prompt (generator)</a></li>\n<li><a href="https://medium.com/@soapsudtycoon/stable-diffusion-trending-on-art-station-and-other-myths-c09b09084e33">Trending on artstation and other myths - part 1</a> - <a href="https://medium.com/@soapsudtycoon/prompt-engineering-trending-on-artstation-and-other-myths-part-2-d61e25a90517">Trending on artstation and other myths - part 2</a> (好文，建议读读)</li>\n</ul>',
id:"/volume1/homes/leo/github/my-blog-code/src/pages/2022/2022-11-29 Stable Diffusion Notes.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2022-11-29T18:40:31.000+08:00",path:"/2022/stable-diffusion-prompt-tips",title:"Stable Diffusion Prompt技巧",excerpt:"",tags:["AI","stable diffusion","机器学习"]}}},{node:{html:'<p>技术圈技术潮流真的是三十年河东，三十年河西。SOA不温不火N多年之后，换了个包装变成Microservice，就火了；之前很多RAD框架，很多DDD框架及产品也是很多年之后随着Low Code/No Code开始火了。Web圈感觉更是如此。服务端渲染框架如JSP在被以Angular, React, Vue等浏览器端渲染的SPA技术吊打多年之后，现在又逐渐开始有东山再起的苗头了。<a href="https://htmx.org/">HTMX</a>技术就是一个例子。</p>\n<p>其实这个技术本身也并不如何神奇，号称让任何html元素变成可ajax也不如何特殊，通过简单的javascript event callback机制都可以实现，不过HTMX采用声明式的定义，将需要用到Javascript的地方都用html element attribute来定义，就让一切变得不那么一样。看上去就像是一个纯静态的html</p>\n<pre><code class="language-html">&#x3C;div hx-post="/mouse_entered" hx-trigger="mouseenter once">\n    [Here Mouse, Mouse!]\n&#x3C;/div>\n</code></pre>\n<p>就是不知道将来会不会直接也变成一个新的HTML标准。</p>\n<h3>What HTMX Does</h3>\n<ul>\n<li>server side rendering</li>\n<li>empower any HTML element with the ability to send AJAX call (all HTTP methods)</li>\n<li>dynamically replace HTML of specified scope</li>\n</ul>\n<h3>Thymeleaf Template Engine</h3>\n<ul>\n<li>server side template engine</li>\n<li>Freemarker vs Velocity (markup tag based rather than plain text based?)</li>\n<li>layout :: fragment</li>\n<li>SpringMVC, return the <code>layout :: fragment</code></li>\n</ul>\n<p><a href="https://www.thymeleaf.org/doc/tutorials/3.0/thymeleafspring.html">https://www.thymeleaf.org/doc/tutorials/3.0/thymeleafspring.html</a></p>\n<h3>WebJars</h3>\n<ul>\n<li>wrap javascript libraries using Jars</li>\n<li>loading static assets???? </li>\n</ul>\n<h1>reading-note #web</h1>',id:"/volume1/homes/leo/github/my-blog-code/src/pages/2022/HTMX.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2022-10-20T13:00:35.000+08:00",path:"/2022/server-side-rendering-htmx",title:"新服务器端渲染Web技术：HTMX",excerpt:"",tags:["htmx","web"]}}},{node:{html:'<p>重要的思维方式：从什么角度看的问题</p>\n<p>怎么定义 <code>task</code>, 从全局的角度看，一个<em>task</em>，有下面两个基本属性：</p>\n<ul>\n<li>location 在哪个node上执行</li>\n<li>state 当前处于什么状态</li>\n</ul>\n<p><strong>task == resource, subtask == partition</strong></p>\n<p>所以，从Helix的角度，一个<em>task</em>也可以认为是一个<em>resource</em>，因为task和resource都有上面两个基本属性。</p>\n<p>一个<code>IdealState</code> /<code>CurrentState</code>也是对某个task/resource来说的。</p>\n<p><code>ZNRecord</code> : Zookeeper Node Record, generic的机制来存数据，类似Dao\n<code>HelixProperty</code>: Domain Object，其实就是封装了ZNRecord，并通过在Helix context有意义的方法。</p>\n<p>比如：</p>\n<ul>\n<li><code>HelixProperty.getBucketSize()</code> -> <code>ZNRecord.getSimpleField()</code></li>\n<li><code>CurrentState.getState()</code> -> <code>ZNRecord.getMapField().get("current_state")</code></li>\n</ul>\n<p>一个Task可以被拆分为小的subtasks，对应的，resource -> partition\n每个task/subtask可以有多个replica，以提高系统的可用性(availability)</p>\n<img src="https://mermaid.ink/img/Zmxvd2NoYXJ0IFRECiAgZGlyZWN0aW9uwqBMUgogIHN1YmdyYXBoIHRhc2sKICAgIFRhc2sgLS0+fHNwbGl0fCBTdWJUYXNrCiAgICBTdWJUYXNrIC0tPnwxLi5ufCBSZXBsaWNhCiAgZW5kCiAgZGlyZWN0aW9uwqBMUgogIHN1YmdyYXBoIHJlc291cmNlCiAgICBSZXNvdXJjZSAtLT4gUGFydGl0aW9uCiAgZW5kCiAgVGFzayAtLmFsaWFzLi0+IFJlc291cmNlCiAgU3ViVGFzayAtLmFsaWFzLi0+IFBhcnRpdGlvbg==" />\n<p>如下信息就是一个ZNRecord:</p>\n<pre><code class="language-json">{\n    "id": "myIndex",\n    "simpleFields": {\n        "NUM_PARTITIONS": "3",\n        "REPLICAS": "2",\n    },\n    "mapFields": {\n        "myIndex_0": {\n            "N1": "ONLINE",\n            "N2": "ONLINE"\n        },\n        "myIndex_1": {\n            "N2": "ONLINE",\n            "N3": "ONLINE"\n        },\n        "myIndex_2": {\n            "N3": "ONLINE",\n            "N1": "ONLINE"\n        }\n    }\n}\n</code></pre>\n<p>注意里面的<code>simpleFields</code>, <code>mapFields</code></p>\n<h3>State</h3>\n<p>不同的应用场景，每个node的状态是什么也不尽相同。Leader/StandBy, Online/Offline等等。每个node的状态机相应的也不同。Helix作为一个框架，就是要隔离这些不同，允许用户自定义状态机，以及状态转换的时候做的动作。</p>\n<p>注意：这里的状态特指每个Node的状态，不是业务逻辑里某个业务对象的状态。常见的状态机定义：</p>\n<ul>\n<li>\n<p>Leader / Standby</p>\n</li>\n<li>\n<p>Master / Slave</p>\n</li>\n<li>\n<p>Online / Offline</p>\n</li>\n<li>\n<p>Task/ScheduledTask</p>\n</li>\n<li>\n<p>StateModelDefinition (状态机定义)只描述整个状态机长什么样，有哪些状态，从哪个状态可以转换到另外的什么状态；但是定义里并不会具体说：转换的时候做什么事情（变的部分；不同的场景不同的处理）</p>\n</li>\n<li>\n<p>而StateModel（状态模型）才是声明状态转换的时候要做什么事情。所以，StateModel更像是个Callback的集合，<em>或者叫TransitionBehavior</em></p>\n</li>\n</ul>\n<h3>Spectator</h3>\n<p>每个node有自己的状态，整个cluster需要一个big picture，那就是ExternalView, 这个view会提供给观测者spectator，来监控cluster状态。</p>\n<h3>HelixAdmin</h3>\n<p>Helix cluster manager，通过这个manager可以创建cluster，获取cluster状态，获得cluster上的resource，创建新的resource. 开启maintenance mode.等等。</p>\n<p>创建一个HelixAdmin：</p>\n<pre><code class="language-java">HelixAdmin admin = new HelixAdmin.Builder()\n    .setZkAddress(zkSrv)\n    .build();\n</code></pre>\n<p>cluster manager可以定义cluster里有哪些状态机；List&#x3C;(clusterName, defName, def)></p>\n<h3>HelixManager</h3>\n<p>这个就是Helix Agent，在participant上面，那就是participant manager，在controller上面，就是controller manager. 任何需要和Helix交互的process都需要它。一般的流程是：</p>\n<pre><code class="language-java">manager = HelixManagerFactory.getZKHelixManager(clusterName, instanceName, ROLE, zkAddr);\nmanager.addPreConnectionCallback(cb);\nmanager.connect();\n....\nmanager.disconnect();\n</code></pre>\n<p>我们需要通过participant manager(HelixManager)来注册状态机工厂。</p>\n<pre><code class="language-java">participantManager.getStateMachineEngine()\n    .registerStateModelFactory(stateModelDefName, stateModelFactory);\n</code></pre>\n<p>Cluster里只有Participant node才有StateMachineEngine，其他controller，spectator都是null.</p>\n<h4>DefaultMessagingService</h4>\n<p>Helix Agent (manager)有一个消息服务，内置一个线程池 TaskExecutor. 只要agent connect到cluster之后，这个消息服务就会被初始化。</p>\n<h3>StateMachineEngine</h3>\n<ul>\n<li>Participant节点用<em>状态机引擎</em>注册<em>状态模型工厂</em></li>\n<li><em>状态模型工厂</em>创建<em>状态模型</em></li>\n<li><em>状态模型</em>处理状态转换消息。</li>\n</ul>\n<p>状态模型其实是我们日常说的状态机。</p>\n<h2>Questions</h2>\n<ul>\n<li><del>HelixAdmin.addStateModelDef vs HelixManager.getStateMachineEngine().registerStateModelFactory</del></li>\n<li>How does Helix dispatch jobs? via messaging?</li>\n</ul>\n<h1>Helix Recipes</h1>\n<h2>Distributed Lock Manager</h2>\n<p>基于zookeeper，但是能解决：</p>\n<ul>\n<li>第一个节点启动就取得所有lock的问题</li>\n</ul>\n<pre><code>ZkClient.connect -> new ZkEventThread(维护一个BlockingQueue&#x3C;ZkEvent>，这样ZkClient收到zookeeper的消息之后会发送ZkEvent到eventThread的blocking queue)\n    -> ZkEventThread 会不停地循环，从blocking queue里获取event之后event.run\n        -> event是一个匿名类\n\nZkClient是一个ZooKeeper的Watcher实现,  ZkClient.process(WatchedEvent) 会调用各种listener.\n\nCallbackHandler.handleChildChange -> enqueTask -> invoke -> \n    HelixTaskExecutor.onMessage -> scheduleTask (提交任务到线程池) ~~-~~> \n        HelixTask.call -> \n            HelixStateTransitionHandler.handleMessage -> invoke (根据StateModel class里方法上Annotation from，to找到对应的method，然后反射地调用。)\n\nZKHelixManager.connect -> createClient (初始化ZkClient) -> zkClient.subscribeStateChanges\n</code></pre>',id:"/volume1/homes/leo/github/my-blog-code/src/pages/2022/Helix Notes.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2022-09-29T19:20:40.000+08:00",path:"/2022/helix-concept-model",title:"Helix概念模型",excerpt:"",tags:["helix","apache","distributed"]}}},{node:{html:"<h1>Thread Model</h1>\n<!-- language:uml -->\n<pre><code>participant IntegrationTest\nparticipant FileStore1\nparticipant HealthReportTimer1\nparticipant HelixTaskExecutor1\nparticipant FileSystemWatchService_master\nparticipant FileStore2\n\nIntegrationTest --> IntegrationTest: startZkServer\nIntegrationTest --> IntegrationTest: setupCluster\nIntegrationTest --> FileStore1 **: start\nFileStore1 --> FileStore1: getHelixManager\nactivate FileStore1\nFileStore1 --> HealthReportTimer1 **: create\nFileStore1 --> HelixTaskExecutor1 **: create\ndeactivate FileStore1\n\nFileStore1 --> FileStore1: registerStateModelFactory\nFileStore1 --> FileStore1: connect to Helix cluster\n\nFileStore1 --> FileStore1: stateModelFactory.createStateModel\\naddExternalViewChangeListener(new Replicator)\n\nFileStore1 --> FileStore1: **OFFLINE -> SLAVE**\nactivate FileStore1\nFileStore1 --> FileStore1: replicator1.start()\\n(no master yet)\ndeactivate FileStore1\n\nIntegrationTest --> FileStore2 **: start\nFileStore2 --> FileStore2: getHelixManager\nFileStore2 --> FileStore2: ...\nFileStore2 --> FileStore2: OFFLINE -> SLAVE\nactivate FileStore2\nFileStore2 --> FileStore2: replicator2.start()\\n(no master yet)\nFileStore2 --> IntegrationTest: report state change\ndeactivate FileStore2\n\nIntegrationTest --> FileStore1: replicator1.onExternalViewChange\nactivate FileStore1\nFileStore1 --> FileStore1: replicator1.start()\\n(still no master yet)\ndeactivate FileStore1\n\nIntegrationTest --> FileStore1: drive to ideal state\nFileStore1 --> FileStore1: **SLAVE -> MASTER**\nactivate FileStore1\nFileStore1 --> FileStore1: replicator1.stop()\nFileStore1 --> FileStore1: checkpointFile.findLastRecordProcessed\nFileStore1 --> FileStore1: high watermark update\nFileStore1 --> FileSystemWatchService_master **: create\nFileStore1 --> IntegrationTest: report state change\ndeactivate FileStore1\n\ngroup file change\n    IntegrationTest --> IntegrationTest: write a file\n\n    FileSystemWatchService_master --> FileSystemWatchService_master: alteration listener\\n monitor file changes\\n死循环\n    FileSystemWatchService_master --> FileStore1: notify changeLogGenerator the file change\n    activate FileStore1\n    FileStore1 --> FileStore1: changeLogGenerator.appendChange\n    deactivate FileStore1\nend\n\nIntegrationTest --> FileStore2: replicator2.onExternalViewChange\nactivate FileStore2\nFileStore2 --> FileStore2: replicator2.start()\\n(there is master now)\nactivate FileStore2\nFileStore2 --> FileStore2: replicator2.startReplication\nactivate FileStore2\nFileStore2 --> BackgroundRsync **: create\ngroup sync file\n    BackgroundRsync --> BackgroundRsync: rsync\\nOnly sync the changeLog from master\\n死循环\n    FileStore2 --> FileSystemWatchService_slave **: create\n    FileSystemWatchService_slave --> FileSystemWatchService_slave: alteration listener\\n monitor file changes\\n死循环\n    FileStore2 --> ChangeLogProcessor **: create\n    ChangeLogProcessor --> ChangeLogProcessor: parse file path from changeLog\\nthen, call rsync to sync the file.\\n死循环\nend\ndeactivate FileStore2\ndeactivate FileStore2\ndeactivate FileStore2\n</code></pre>\n<p>Notes:</p>\n<ol>\n<li>Replicator is a RoutingTableProvider (Spectator) 因为要查找其他instance</li>\n<li>When a Participant is interrupted, there could be no chance to execute the state transition like <code>MASTER->SLAVE</code>, the process just aborts.</li>\n<li>If FileStore1 is down, FileStore2 will become the new Master, and it will stop the <code>replicator</code> first, which will shutdown the original <code>backgroundRsync</code>, <code>FSWatchService_slave</code> and <code>ChangeLogProcessor</code> threads first.</li>\n</ol>",id:"/volume1/homes/leo/github/my-blog-code/src/pages/2022/Rsync Replicated File System with Helix.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2022-09-28T15:40:41.000+08:00",path:"/2022/thread-model-of-rsync-based-distributed-file-system-helix-cluster",title:"基于rsync的分布式文件系统Helix集群线程模型分析",excerpt:"",tags:["helix","distributed","rsync"]}}},{node:{html:"<h2>Redis Commands 缩写</h2>\n<p>Redis里存储的value是有类型的，不同类型的值需要用不同的command来操作：</p>\n<ul>\n<li>List -> L<Cmd>, e.g., LPUSH, LLEN</li>\n<li>Hash -> H<Cmd>, e.g., HGET, HKEYS</li>\n<li>Set -> S<Cmd>, e.g, SADD, SISMEMBER,</li>\n<li>Sorted Set -> Z<Cmd></li>\n</ul>\n<p>其他缩写：</p>\n<ul>\n<li>M<Cmd> , Multiple</li>\n<li>R<Cmd>, Remove or Right(tail)</li>\n<li>B<Cmd>, Blocking, for instance, BLPOP (pop from head), BRPOP (pop from tail)</li>\n</ul>",id:"/volume1/homes/leo/github/my-blog-code/src/pages/2022/Redis Commands.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2022-09-21T20:08:16.000+08:00",path:"/2022/redis-commands",title:"Redis Commands 缩写",excerpt:"",tags:["redis"]}}},{node:{html:'<p>从26号拿到机器，到现在，也使用了一段时间了，因为有用苹果笔记本及iPad的底子，使用起iOS来，有一些不适应，但也还好，总结一下使用感受吧。</p>\n<p>作为一个一直使用安卓手机的用户，刚刚切换都苹果系统，肯定会不适应，虽然我会时刻注意秉持客观的态度，但是，不可避免会受多年使用习惯的影响，有一些不公允的意见或结论。我只能尽力自省。</p>\n<p>鉴于很多数码博主已经对十三香的影像功能做了很深入的评测，这里忽略这一部分。</p>\n<h2>TLDR;</h2>\n<ul>\n<li>一般的观念里，iOS用户比安卓用户家底厚，存在“劫富济贫”的情况</li>\n<li>在人性化设计方面，安卓正在快速赶超iOS</li>\n<li>iOS很多设计让人感觉是一种不合潮流的倔强</li>\n<li>苹果闭源系统在有些方面要比开源系统更有优势。</li>\n</ul>\n<h2>吐槽部分</h2>\n<h3>本地化的应用商店</h3>\n<p>换新手机肯定要把应用搬家，除了通过自带的“转移到iOS”应用将通讯录，短信等数据同步到新手机上之外，对于应用程序，我只能用笨办法：一个一个地手动安装。</p>\n<p>可查找了几个常用app之后，我发现居然都找不到，比如：高德地图，喜马拉雅，酷我音乐等等。这些app可都是大厂作品，没有iOS版明显不合乎逻辑呀，折腾了半天之后才想起来，我的苹果账号地区设置的是美丽国。试着改到中国，哈，it works!</p>\n<p>看来iOS应用商店是一个账号两个系统，技术上应该可以做到如果用户查找的app在一个系统不存在，但是通过app name的语言，应该可以到对应地区的系统中搜索一下，如果存在就提醒一下用户。可处处讲究用户体验的苹果却没有这么做。</p>\n<h3>“劫富济贫”</h3>\n<p>我是一个Anki闪卡的老用户，在我印象里Anki也是一个公益免费app，毕竟AnkiDroid是开源的，AnkiWeb也是免费的。可当我在iOS应用商店中找到Anki时，发现它居然是一个收费应用，25美刀。好吧，就算我支持Anki的发展了。</p>\n<p>可我真想不通这背后的逻辑。</p>\n<h3>不一致的“回退”逻辑</h3>\n<p>安卓系统的回退操作逻辑很简单：在屏幕左右任意一侧划向中间，就可以返回上一级，如果已经是应用程序的首页，再返回就会返回到桌面。</p>\n<p>但是iOS的逻辑是：在应用程序中，只能从左侧划，当已经是应用程序的首页时，必须向上划才能返回桌面。应用中从左向右，退出应用从下向上，本身就不一致。更加糟糕的是很多应用里自定义了返回逻辑，比如微信朋友圈看照片时，多张照片左右划动换照片，但是返回操作却不是从左向右划了，而是<strong>单击</strong>。另外一些应用程序（比如Anki）的左侧是一个导航菜单，左侧右划会和滑出左侧导航菜单冲突。</p>\n<p>顺便吐槽一下微信，在安卓系统中，“发送”按钮就在输入框的同一水平的右侧。但是，iOS下却被放置在右下方，别扭。</p>\n<h3>手感</h3>\n<p>我用的是13 Pro Max，这边框实在是太宽了，加上又是非曲面屏，真的很硌手。立马怀念起我的Find X2 Pro。昨天在Vivo专卖店里试了试X70 Pro Plus，那轻盈的机身，圆润的手感，再摸摸自己兜里硌手的十三香，唉！</p>\n<p>硌手的情况在加上一个手机壳后有所改善。</p>\n<h3>反潮流</h3>\n<ul>\n<li>充电头居然不是usb c</li>\n<li>没有指纹识别。FaceID平时可能也还好，但是疫情期间，戴口罩解锁真麻烦。</li>\n<li>在快充大行其道的今天，安卓旗舰都65W, 120W了，苹果还20W，真心无语。</li>\n</ul>\n<h3>双拼支持</h3>\n<p>我是一个老“自然码”用户，但是iOS没有自然码输入法，有教程说通过imazing备份，修改plist文件后再恢复，就可以使用自然码双拼方案，可不小心改了设置就没了，还要花将近三百买正版imazing才能实现。干脆改用<code>小鹤双拼</code>了；因为Mac里也默认支持小鹤双拼了，至少有一个一致的体验。</p>\n<p>花了一小时学习新编码，就可以上手了，当时感觉转换应该挺简单，可十多天之后，我才发现我还是低估了二十多年来养成的肌肉记忆。<code>ou</code>, <code>iang</code>, <code>ing</code>, <code>iao</code>, <code>uai</code>, <code>ai</code>, <code>ou</code>, <code>ie</code>, <code>ei</code>, <code>un</code>, <code>ao</code>, <code>in</code>, 这些韵母和自然码不同的编码真的是折磨。</p>\n<h3>其他</h3>\n<ul>\n<li>没有工作日闹铃了</li>\n<li>没找到合适的门禁卡工具；</li>\n<li>\n<p>没有找到快捷方式（扫一扫）</p>\n<ul>\n<li>通过快捷指令实现</li>\n</ul>\n</li>\n<li>\n<p>OpenVPN 不支持按照应用设置规则</p>\n<ul>\n<li>找到一个<a href="https://www.codingmerc.com/blog/ios-vpn-on-demand-profile-with-openvpn/">教程</a>，还没来得及试。</li>\n</ul>\n</li>\n<li>没有息屏显示</li>\n<li>\n<p>息屏手电筒常被误触</p>\n<ul>\n<li>之前就奇怪很多苹果机用户的手机经常亮着闪光灯，现在才明白为什么。</li>\n</ul>\n</li>\n<li>截屏快捷键和安卓相反： up + 电源</li>\n</ul>\n<h2>优点</h2>\n<p>吐槽了半天，下面说说十三香的优点。</p>\n<h3>电池续航</h3>\n<p>我之前用的OPPO FindX2 Pro，因为用了120HZ高刷，那电量掉的叫一个快，把我一个燃油车主生生整成天天电量焦虑的电动车主。可换了十三香之后，得益于苹果ProMotion技术，那真是省电啊。</p>\n<p>想想安卓阵营，最早推出120hz高刷，可耗电问题却被后发的苹果超过，悲哀啊！</p>\n<h3>耳机效果不错</h3>\n<p>之前在安卓机上用AirPod，音质感觉还可以，但是连上同源的苹果机之后，感觉音质提升了一大截，有了环绕立体声的感觉，赞！</p>\n<h3>集成系统的好处</h3>\n<p>Note可以直接同步，很多应用数据（比如Notability, MarginNote）可以通过icloud在不同的苹果设备之间同步，很方便。</p>\n<p>虽然安卓机里也可以通过第三方系统，比如google drive, 百度网盘，dropbox等等实现，但是多系统的匹配，各种复杂的配置，导致用户体验很不好。</p>\n<h3>CarPlay系统</h3>\n<p>我的汽车上有CarPlay系统，但是以前用安卓系统一直没机会体验，换了苹果系统能用了，感受还可以，操作界面简洁，明了。界面上只保留地图，音乐，消息应用，让你专心开车。</p>\n<p>不过习惯把手机卡在控制台上方之后，感觉车的原屏幕设计有点低，每次还有特地低头去看，不太方便。</p>\n<h3>其他</h3>\n<ul>\n<li>公交卡可用，还很灵敏</li>\n<li>对于一些穿戴设备的适配较好，我跑步用唯乐小黑，刚换机跑完之后发现配速居然神奇的提升了。结合地图测距，发现还是苹果机的相对更准确些。可能是因为安卓机型太多，适配不免出现问题，而苹果机相对容易，所以更准确些。</li>\n<li>快捷方式app挺有用，就是手机上的no code，只是真用起来，还是像其他low code, no code系统一样，问题多多。</li>\n</ul>',id:"/volume1/homes/leo/github/my-blog-code/src/pages/2021/一个安卓老用户换十三香之后的感受.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2021-10-12T15:52:28.000+08:00",path:"/2021/iphone",title:"一个安卓老用户换十三香之后的感受",excerpt:"",tags:[]}}}],pathPrefix:"",first:!0,last:!1,index:1,pageCount:4,additionalContext:{}}}}});
//# sourceMappingURL=path---index-e2bf590c63ba6c88d316.js.map